<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图片文件上载</title>
      <link href="/2024/03/26/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E4%B8%8A%E8%BD%BD/"/>
      <url>/2024/03/26/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E4%B8%8A%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="图片文件上载"><a href="#图片文件上载" class="headerlink" title="图片文件上载"></a>图片文件上载</h3><h4 id="图片文件上载介绍"><a href="#图片文件上载介绍" class="headerlink" title="图片文件上载介绍"></a>图片文件上载介绍</h4><p>HTTP 文件上载是指通过 HTTP 协议将用户提交的文件上传到服务器。HTTP 文件上载通常使用 POST 方法，将文件作为请求体发送。</p><p>在 HTTP 文件上载中，用户需要使用 Web 界面上传文件。通常，Web 界面会提供文件选择框和上传按钮等控件，以便用户选择要上传的文件，并指示上传的 URL 或文件名。用户可以选择文件后，点击上传按钮，将文件上传到服务器。</p><p>HTTP 文件上载的基本原理是将文件作为一个 HTTP 请求体发送。HTTP 请求体通常包括文件的内容、文件名、文件类型等信息。服务器接收到请求后，会根据请求中的内容、文件名等信息，找到并读取文件，并将其存储到服务器上相应的位置。</p><h4 id="multipart-form-data格式"><a href="#multipart-form-data格式" class="headerlink" title="multipart&#x2F;form-data格式"></a>multipart&#x2F;form-data格式</h4><p><code>multipart/form-data</code> 是一种用于在 HTTP 请求中传输二进制数据的标准格式。通常，它用于在 Web 表单中上传文件，但也可以用于传输其他类型的二进制数据。</p><p>当你提交包含文件上传的表单时，浏览器通常会使用 <code>multipart/form-data</code> 编码类型。这种编码类型允许将表单数据以多个部分（parts）的形式传送，每个部分都有自己的内容类型（Content-Type）和一些额外的描述信息。</p><p><code>multipart/form-data</code> 格式的请求主体通常由多个部分组成，每个部分包含一个表单字段的数据。每个部分由一个包含头部信息和实际数据的块组成。头部信息包含了 Content-Disposition、Content-Type 等字段，用于描述该部分的属性</p><h4 id="MutipartFile接口"><a href="#MutipartFile接口" class="headerlink" title="MutipartFile接口"></a>MutipartFile接口</h4><p>在java中，MutipartFile是Spring框架提供的一个接口，用于处理文件上传。</p><p>MutipartFile接口定义了用于访问上传文件的方法，它通常用于处理通过HTML表单上传的文件。这个接口的实现类可以包含上传的内容、元数据和一些额外的信息。在处理文件上传时，Spring MVC控制器可以使用MutipartFile对象来获取上传的文件数据。</p><p>MutipartFile接口的一些常见方法：</p><ul><li>getOriginalFilename():返回上传文件的原始文件名</li><li>getContentType():返回上传文件的内容类型</li><li>getSize():返回上传文件的大小，单位为字节</li><li>getBytes():返回上传文件的字节数组</li><li>getInputStream():返回一个用于读取上传文件内容的InputStream</li><li>isEmpty():检查上传文件是否为空</li><li>transferTo():用于将上传的文件内容保存到指定的目标文件(file)中的方法</li></ul><h4 id="在Spring-Boot中实现图片文件上载功能"><a href="#在Spring-Boot中实现图片文件上载功能" class="headerlink" title="在Spring Boot中实现图片文件上载功能"></a>在Spring Boot中实现图片文件上载功能</h4><ol><li><p>首先，在配置文件中定义相对应系统类型的上传文件存储路径，以及允许上传的图片格式后缀(写在相应的applicaiton-…yml中)，这些配置可以通过@Value注解到业务层</p><pre><code class="highlight xml"># 文件上传路径upload:  dir: D:/coolshark_pms/upload  #LINUX系统  # dir:  /opt/coolshark_pms/upload</code></pre></li><li><p><strong>实现图片文件上传业务层相关接口以及实现类</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 文件上传接口</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUploadService</span> &#123;    <span class="comment">/**</span><span class="comment">     * 文件上传</span><span class="comment">     * <span class="doctag">@param</span> path 文件存储路径</span><span class="comment">     * <span class="doctag">@param</span> file 文件对象</span><span class="comment">     * <span class="doctag">@return</span> 文件的访问地址</span><span class="comment">     */</span>    UrlVO <span class="title function_">uploadFile</span><span class="params">(String path, MultipartFile file)</span>;&#125;</code></pre><p>(说明：urlVO类是向前端返回该图片文件的url路径，用于前端展示图片内容，MultipartFile接口用于处理前端传来的图片文件)</p><pre><code class="highlight java"><span class="meta">@Service</span> <span class="comment">//Spring注解 表示将此类注入spring容器并由spring管理</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUploadService</span> &#123;    <span class="comment">//定义日期格式化对象 用于生成保存文件的目录</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">DATE_TIME_FORMATTER</span> <span class="operator">=</span>DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM&quot;</span>);    <span class="comment">// 保存文件的路径</span>    <span class="meta">@Value(&quot;$&#123;upload.dir&#125;&quot;)</span> <span class="comment">//属性注入 内容来自配置文件</span>    <span class="keyword">private</span> File uploadDir;    <span class="meta">@Override</span>    <span class="keyword">public</span> UrlVO <span class="title function_">uploadFile</span><span class="params">(String path, MultipartFile file)</span> &#123;        <span class="comment">//定义保存文件的目录</span>        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDir,path);        <span class="comment">//获取当前的日期</span>        <span class="type">String</span> <span class="variable">dateDir</span> <span class="operator">=</span> LocalDate.now().format(DATE_TIME_FORMATTER);        <span class="comment">// 包含日期的文件保存路径</span>        <span class="type">File</span> <span class="variable">dataDirFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir,dateDir);        log.info(<span class="string">&quot;文件保存路径:&#123;&#125;&quot;</span>,dataDirFile.getAbsolutePath());        <span class="comment">//创建目录</span>        <span class="keyword">if</span>(!dataDirFile.exists())&#123;            dataDirFile.mkdirs(); <span class="comment">//如果不存在 就创建目录</span>        &#125;        <span class="comment">//获取文件的原始名 </span>        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();        <span class="comment">//获取文件的扩展名</span>        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));        <span class="comment">//重新生成文件名 UUID会生成64位随机</span>        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID()+suffix;        <span class="comment">//创建文件</span>        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dataDirFile,fileName);        log.info(<span class="string">&quot;文件保存路径:&#123;&#125;&quot;</span>,dest.getAbsolutePath());        <span class="comment">//保存文件</span>        <span class="keyword">try</span> &#123;            <span class="comment">//将前端传来的file内容复制到dest文件中</span>            file.transferTo(dest);            <span class="comment">//返回文件的访问地址</span>            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>+dir.getName()+<span class="string">&quot;/&quot;</span>+dateDir+<span class="string">&quot;/&quot;</span>+fileName;            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UrlVO</span>(url);        &#125; <span class="keyword">catch</span> (IOException e) &#123;            log.error(<span class="string">&quot;保存文件失败&quot;</span>,e);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileUploadException</span>(<span class="string">&quot;保存文件失败&quot;</span>);        &#125;    &#125;&#125;</code></pre></li><li><p><strong>实现图片文件上传控制层</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 文件上传控制器</span><span class="comment"> */</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(&quot;/upload&quot;)</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> IUploadService uploadService;    <span class="meta">@PostMapping(&quot;/&#123;path&#125;&quot;)</span>    <span class="keyword">public</span> JsonResult&lt;UrlVO&gt; <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@PathVariable</span> String path, MultipartFile file)</span>&#123;        log.info(<span class="string">&quot;开始处理[文件上传]的请求,参数&#123;&#125;&quot;</span>,path);        log.info(<span class="string">&quot;开始处理[文件上传]的请求,参数&#123;&#125;&quot;</span>,file);        <span class="type">UrlVO</span> <span class="variable">urlVO</span> <span class="operator">=</span> uploadService.uploadFile(path,file);        <span class="keyword">return</span> JsonResult.ok(urlVO);    &#125;&#125;</code></pre></li><li><p><strong>设置静态资源目录显示远程图片</strong></p><p>在Spring Boot中，可以通过在application.yml文件中配置静态资源目录来设置静态资源的路径。设置完成后，Spring Boot就会将静态资源路径添加到默认的静态资源路径中，使得我们可以访问这些资源。</p><pre><code class="highlight xml">  # 文件静态资源映射spring:  web:    resources:      static-locations: classpath:/static/, file:$&#123;upload.dir&#125;</code></pre><p>在上述配置中，classpath:&#x2F;static&#x2F;表示静态资源存放在src&#x2F;main&#x2F;resources&#x2F;static目录下，而file:&#x2F;D:&#x2F;upload&#x2F;dir表示静态资源还存放在D:&#x2F;upload目录下</p></li><li><p>补充类</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 存储文件上传的URL</span><span class="comment"> */</span><span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span><span class="meta">@NoArgsConstructor</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrlVO</span> &#123;    <span class="keyword">private</span> String url;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局统一异常处理</title>
      <link href="/2024/03/26/%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2024/03/26/%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="全局统一异常处理"><a href="#全局统一异常处理" class="headerlink" title="全局统一异常处理"></a>全局统一异常处理</h3><h4 id="1-什么是全局统一异常处理"><a href="#1-什么是全局统一异常处理" class="headerlink" title="1.什么是全局统一异常处理"></a>1.什么是全局统一异常处理</h4><p>(在使用全局统一异常处理之前,后端都是在业务层抛出异常,在控制层处理异常,这大大的增加了控制层的代码量不利于开发)</p><p>统一异常处理是一种软件开发的最佳实践,旨在通过捕获并处理程序运行时可能出现的异常和错误,以提高程序的可靠性和稳定性。它涉及到将异常和错误处理代码从主要业务逻辑中分离出来,以便在发生异常时进行一致的响应,无论是记录日志\发送警报还是向用户显示友好的错误消息.</p><p>在统一异常处理中,通常会定义通用的异常类型和处理程序,以便在整个应用程序中使用.这些异常类型可以是内置的,例如java中的NullPointerException,也可以是自定义的,例如应用程序特定的业务逻辑异常.处理程序可以将异常记录到日志\向开发团队发送警报或向用户显示友好的错误消息,以便更好地理解发生了什么,并且可以更快地解决问题.</p><p>通过使用统一异常处理,可以避免由于为处理异常而导致应用程序崩溃,同时可以更快地诊断和解决问题,提高应用程序的可维护性和可靠性.</p><h4 id="2-Spring-MVC-统一异常处理"><a href="#2-Spring-MVC-统一异常处理" class="headerlink" title="2.Spring MVC 统一异常处理"></a>2.Spring MVC 统一异常处理</h4><p>@RestControllerAdvice 和 @ControllerAdvice 两个注解是用来实现Spring MVC 控制层全局异常处理功能的 </p><p>@ControllerAdvice注解常用于处理传统的MVC应用程序中的异常,例如Thymeleaf\jsp或者FreeMarker等视图技术构建的Web应用程序.</p><p>@RestControllerAdvice注解通常用于处理RESTful服务中的异常,并返回JSON格式的数据,这也是现在主流使用的技术</p><h4 id="3-RestControllerAdvice-是什么注解-主要作用和原理是什么"><a href="#3-RestControllerAdvice-是什么注解-主要作用和原理是什么" class="headerlink" title="3.@RestControllerAdvice 是什么注解 主要作用和原理是什么"></a>3.@RestControllerAdvice 是什么注解 主要作用和原理是什么</h4><p>@RestControllerAdvice 是 Spring Framework 中的一个注解，用于全局处理控制器（Controller）层的异常。它的主要作用是集中处理在<strong>多个控制器中</strong>可能出现的异常，以提供一致的异常处理逻辑。</p><p>以下是 <code>@RestControllerAdvice</code> 的主要作用和原理：</p><ol><li><p><strong>全局异常处理：</strong> <code>@RestControllerAdvice</code> 可以用于定义一些全局性的异常处理逻辑，这样当应用中的任何控制器抛出异常时，都可以在这里定义相应的处理方法，而不需要在每个控制器中都单独处理。</p></li><li><p><strong>全局数据绑定：</strong> 除了异常处理，<code>@RestControllerAdvice</code> 还可以用于全局数据绑定。通过在该注解下定义的方法中添加 <code>@ModelAttribute</code> 注解，可以在每个请求之前将一些数据绑定到模型中，这样可以在每个控制器中共享相同的模型属性。</p></li><li><p><strong>全局数据预处理：</strong> 提供一个统一的地方进行请求参数的预处理，比如日期格式化、参数解密等，以确保在控制器方法执行之前进行必要的处理。</p></li></ol><p><strong>原理：</strong></p><p>当使用 <code>@RestControllerAdvice</code> 注解标记一个类时，Spring 会自动将其识别为全局异常处理类。这个类中的方法可以使用 <code>@ExceptionHandler</code>、<code>@InitBinder</code> 和 <code>@ModelAttribute</code> 注解来处理异常、数据绑定和数据预处理。</p><ul><li><code>**@ExceptionHandler</code>：**用于处理特定异常类型的方法。</li><li><code>@InitBinder</code>：用于定义 Web 数据绑定初始化代码的方法，可以用于配置数据绑定规则。</li><li><code>@ModelAttribute</code>：用于将控制器中的某个方法提取出来，以便在所有处理器映射中共享模型属性。</li></ul><p><strong>4.在应用程序中使用全局统一异常</strong></p><p>1.不使用统一的JSON返回结果.</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 全局异常处理器</span><span class="comment"> * 用于处理所有控制器抛出的异常</span><span class="comment"> * <span class="doctag">@author</span> LiFuteng</span><span class="comment"> */</span><span class="meta">@RestControllerAdvice</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;    <span class="comment">/**</span><span class="comment">     * 处理EntityNotFoundException异常</span><span class="comment">     * <span class="doctag">@param</span> e EntityNotFoundException异常</span><span class="comment">     * <span class="doctag">@return</span> 异常信息</span><span class="comment">     */</span>    <span class="meta">@ExceptionHandler(EntityNotFoundException.class)</span>    <span class="keyword">public</span> String <span class="title function_">handleEntityNotFoundException</span><span class="params">(EntityNotFoundException e)</span> &#123;        <span class="keyword">return</span> e.getMessage();    &#125;    <span class="comment">/**</span><span class="comment">     * 处理UserNotFoundException异常</span><span class="comment">     * <span class="doctag">@param</span> e UserNotFoundException异常</span><span class="comment">     * <span class="doctag">@return</span> 异常信息</span><span class="comment">     */</span>    <span class="meta">@ExceptionHandler(UserNotFoundException.class)</span>    <span class="keyword">public</span> String <span class="title function_">handleUserNotFoundException</span><span class="params">(UserNotFoundException e)</span> &#123;        <span class="keyword">return</span> e.getMessage();    &#125;    <span class="comment">/**</span><span class="comment">     * 处理BlankParameterException异常</span><span class="comment">     * <span class="doctag">@param</span> e BlankParameterException异常</span><span class="comment">     * <span class="doctag">@return</span> 异常信息</span><span class="comment">     */</span>    <span class="meta">@ExceptionHandler(BlankParameterException.class)</span>    <span class="keyword">public</span> String <span class="title function_">handleBlankParameterException</span><span class="params">(BlankParameterException e)</span> &#123;        <span class="keyword">return</span> e.getMessage();    &#125;&#125;</code></pre><p>2.使用统一的JSON返回结果,需要定义相应的JsonResult类(JsonResult统一结果返回是一种前后端交互规范)</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 全局异常处理类</span><span class="comment"> */</span><span class="meta">@RestControllerAdvice</span> <span class="comment">//全局异常处理类声明</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;    <span class="meta">@ExceptionHandler</span> <span class="comment">//声明处理的异常类型</span>    <span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title function_">handleServiceException</span><span class="params">(ServiceException e)</span>&#123;        log.warn(<span class="string">&quot;程序运行出现ServiceException异常,将统一处理&quot;</span>);        log.warn(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>,e.getMessage());        <span class="keyword">return</span> JsonResult.fail(e);    &#125;    <span class="comment">/**</span><span class="comment">     * 数据验证异常处理 用于处理请求参数校验失败的情况</span><span class="comment">     */</span>    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span>    <span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title function_">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span>&#123;        log.warn(<span class="string">&quot;程序运行出现MethodArgumentNotValidException异常,将统一处理&quot;</span>);        log.warn(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>,e.getMessage());        <span class="keyword">return</span> JsonResult.fail(ServiceCode.ERR_BAD_REQUEST, e.getMessage());    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端跨域访问</title>
      <link href="/2024/03/26/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/"/>
      <url>/2024/03/26/%E5%89%8D%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="配置跨域访问"><a href="#配置跨域访问" class="headerlink" title="配置跨域访问"></a>配置跨域访问</h3><h4 id="前端技术使用Vue"><a href="#前端技术使用Vue" class="headerlink" title="前端技术使用Vue"></a>前端技术使用Vue</h4><p>由于前端和后端分别使用不同的Web服务器（Node.js和SpringBoot），我们需要配置跨域访问以允许数据通信。</p><p>在前端项目的根目录下，找到.env.development文件，并将 请求映射到后端项目的地址</p><pre><code class="highlight vue">VUE_APP_BASE_API = &#x27;http://localhost:9081&#x27;</code></pre><h4 id="后端跨域配置类"><a href="#后端跨域配置类" class="headerlink" title="后端跨域配置类"></a>后端跨域配置类</h4><p>在后端项目中，添加一个跨域配置类 CorsConfig，该类将为Spring MVC增加一个CORS（跨域资源共享）跨域过滤器。这样，SpringBoot的服务将支持跨域请求。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 跨域访问设置 解决前后端分离前端到后端的访问跨域问题</span><span class="comment"> */</span><span class="meta">@Configuration</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;    <span class="meta">@Bean</span>    <span class="keyword">public</span> FilterRegistrationBean&lt;CorsFilter&gt; <span class="title function_">corsFilterFilterRegistrationBean</span><span class="params">()</span>&#123;        <span class="comment">//通过该对象设置跨域访问</span>        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();        config.setAllowCredentials(<span class="literal">true</span>); <span class="comment">//允许跨域访问</span>        config.addAllowedOrigin(<span class="string">&quot;http://localhost:9528&quot;</span>); <span class="comment">//允许请求的来源</span>        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>); <span class="comment">//允许所有请求头</span>        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>); <span class="comment">//允许所有的请求方法</span>        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,config); <span class="comment">//开发所有的请求路径</span>        FilterRegistrationBean&lt;CorsFilter&gt; bean =                <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source)); <span class="comment">//注册过滤器</span>        bean.setOrder(Ordered.HIGHEST_PRECEDENCE); <span class="comment">//设置过滤器的优先级(值越小 优先级越高)</span>        <span class="keyword">return</span> bean;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端交互规范</title>
      <link href="/2024/03/26/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E8%A7%84%E8%8C%83/"/>
      <url>/2024/03/26/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="前后端交互规范"><a href="#前后端交互规范" class="headerlink" title="前后端交互规范"></a>前后端交互规范</h3><h4 id="前后端数据传输规范"><a href="#前后端数据传输规范" class="headerlink" title="前后端数据传输规范"></a>前后端数据传输规范</h4><p>我们的RABC系统采用了前后端分离的设计，前端负责用户交互，后端处理业务功能。在前后端之间进行数据传递时，为了确保数据传输的一致性和规范性，我们制定了以下前后端数据通信规范。</p><p>RESTful风格的数据传输建议虽然被提出，但实际上并没有被大多数企业完全接受。在开发应用中，通常会对RESTful规范进行一定程度的裁剪和适配。因此，我们采用了一种通用的数据传输规范，以满足企业应用的需求，包括RBAC权限管理模块的开发。</p><p>前端向后端发送数据的标准约定如下：</p><ul><li>数据发送采用HTTP的POST和GET方法</li><li>在数据传输时，URL采用RESTful风格</li><li>对于ID等关键数据，使用URL进行传输；其他数据以JSON格式打包，并通过请求Body部分进行传输。</li></ul><p>后端返回数据的规则如下：</p><ul><li>为了区分网络错误和业务错误，业务处理结果的HTTP状态码统一为200。业务错误的详细信息则通过JSON返回。</li><li>所有返回数据都以JSON格式打包，包含以下四个属性：code、message、data。</li><li>code:表示业务处理结果，2XXXX表示处理成功，4XXXX、5XXXX等表示业务错误。</li><li>message：在出现错误时，表示错误的具体消息；处理正确时，该字段可以为空或者只包含“OK”。</li><li>data:处于正确时，包含业务处理的结果，例如查询结果集或单条查询记录</li></ul><p>通过遵循这些前后端数据传输规范，我们可以确保数据在前后端之间的传递是一致且规范的，从而提高系统的可维护性和稳定性。这也有助于前端和后端开发人员更好地协作，并更容易诊断和解决问题。</p><h4 id="设计JsonResult统一返回结果"><a href="#设计JsonResult统一返回结果" class="headerlink" title="设计JsonResult统一返回结果"></a>设计JsonResult统一返回结果</h4><p>在前后端分离的设计中，前端通常使用JavaScript直接发送和接受JSON格式的数据，而后端使用强类型语言（例如java）来处理数据。为了实现前后端之间的数据传输的一致性，我们可以设计一个统一的返回结果类型JsonResult，并通过泛型和静态方法简化其使用方式。同时，我们可以使用枚举类型来约定错误状态码，以便统一处理错误情况</p><pre><code class="highlight java"><span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonResult</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;    <span class="comment">/**</span><span class="comment">     * 状态码, 20000表示成功</span><span class="comment">     */</span>    <span class="keyword">private</span> Integer code;    <span class="comment">/**</span><span class="comment">     * 操作“失败”时的描述文本，正确时候可能为null</span><span class="comment">     */</span>    <span class="keyword">private</span> String message;    <span class="comment">/**</span><span class="comment">     * 操作“成功”时响应的数据</span><span class="comment">     */</span>    <span class="keyword">private</span> T data;     <span class="keyword">public</span> <span class="keyword">static</span> JsonResult&lt;Void&gt; <span class="title function_">ok</span><span class="params">()</span> &#123;        <span class="keyword">return</span> ok(<span class="literal">null</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; JsonResult&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span> &#123;        JsonResult&lt;T&gt; jsonResult = <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;();        jsonResult.setCode(ServiceCode.OK.getValue());        jsonResult.setData(data);        jsonResult.message = <span class="string">&quot;OK&quot;</span>;        <span class="keyword">return</span> jsonResult;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult&lt;Void&gt; <span class="title function_">fail</span><span class="params">(ServiceException e)</span> &#123;        <span class="keyword">return</span> fail(e.getServiceCode(), e.getMessage());    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult&lt;Void&gt; <span class="title function_">fail</span><span class="params">(ServiceCode serviceCode, String message)</span> &#123;        JsonResult&lt;Void&gt; jsonResult = <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;();        jsonResult.setCode(serviceCode.getValue());        jsonResult.setMessage(message);        <span class="keyword">return</span> jsonResult;    &#125;    <span class="comment">/**</span><span class="comment">     * 将当前对象转换为JSON字符串</span><span class="comment">     * <span class="doctag">@return</span> 当前对象的JSON字符串表示</span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">toJson</span><span class="params">()</span> &#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(<span class="built_in">this</span>);        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;            e.printStackTrace();            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;    &#125;&#125;</code></pre><p>在上述代码中，我们定义了 JsonResult 类，用于统一的JSON返回结果。它包括了状态码 code，描述信息 message，以及响应数据 data。通过 ServiceCode 枚举类型来约定不同业务状态的状态码，以便统一处理。</p><p>同时，我们还定义了一些静态方法，例如 ok() 用于表示操作成功，fail() 用于表示操作失败。这些方法可以简化在控制器中的返回结果的构建。</p><p>ServiceCode 枚举类型用于定义不同的服务状态码，您可以根据具体需求进行扩展和完善。</p><p>业务异常 ServiceException 类作为异常的基类，用于包装业务状态码和错误消息。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置密码加密</title>
      <link href="/2024/03/26/%E9%85%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
      <url>/2024/03/26/%E9%85%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="配置密码加密"><a href="#配置密码加密" class="headerlink" title="配置密码加密"></a>配置密码加密</h3><p>在信息安全中，加密分为一般信息加密和密码加密两种，一般信息加密需要可逆操作，即明文加密为密文，密文可以解密为明文，而密码加密则采用单向编码，不需要解密，直接比较密文即可验证原文，因此更加安全。</p><p>一般使用消息摘要算法进行单向不可逆运算来进行密码加密，比如MD5、SHA256、SHA512等算法，这些算法具有单向运算，不可逆向运算，非常适合用于密码加密，需要注意的是，消息摘要不是加密，而是一种用于秘密加密的技术。</p><p><strong>密码加密技术是一种将密码转换成不可逆的、难以破解的密文的方法，以保证用户密码的安全性。</strong></p><ul><li>MD5（Message Digest Algorithm 5）：一种广泛使用的密码哈希函数，将任意长度的输入（明文）通过哈希算法，输出固定长度的哈希值（密文），不可逆。</li><li>SHA-2（Secure Hash Algorithm 2）：SHA-2 包含多个算法，比如 SHA-256，SHA-384 和 SHA-512，用于计算信息的哈希值，是一种更安全的哈希算法，比 MD5 更难以破解。</li><li>BCrypt：一种基于 Blowfish 加密算法的密码哈希函数，加密后的密文长度固定为 60 个字符，可以设置迭代次数，防止暴力破解。</li><li>PBKDF2（Password-Based Key Derivation Function 2）：一种基于密码的密钥派生函数，可以根据一个密码和一个盐生成密钥，提高密码的安全性。</li></ul><h4 id="Spring提供了密码加密算法，可以帮助保护用户密码"><a href="#Spring提供了密码加密算法，可以帮助保护用户密码" class="headerlink" title="Spring提供了密码加密算法，可以帮助保护用户密码"></a>Spring提供了密码加密算法，可以帮助保护用户密码</h4><p>可以通过添加一个PasswordEncoder配置来实现密码加密</p><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordEncoderConfig</span> &#123;    <span class="comment">/**</span><span class="comment">     * 为 Spring Security 提供密码加密器</span><span class="comment">     * <span class="doctag">@return</span> 密码加密器</span><span class="comment">     */</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;        <span class="type">PasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span>                PasswordEncoderFactories.createDelegatingPasswordEncoder();        log.debug(<span class="string">&quot;配置委托密码编码器 &#123;&#125;&quot;</span>, passwordEncoder.getClass().getName());        <span class="keyword">return</span> passwordEncoder;    &#125;&#125;</code></pre><p>使用加密器加密密码</p><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@SpringBootTest</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordEncoderTests</span> &#123;    <span class="meta">@Autowired</span> <span class="comment">//注入加密器实例</span>    PasswordEncoder passwordEncoder;    <span class="meta">@Test</span>    <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">()</span>&#123;        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;         <span class="comment">//使用加密器生成密文</span>        <span class="type">String</span> <span class="variable">encodedPassword</span> <span class="operator">=</span> passwordEncoder.encode(password);        log.debug(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, password, encodedPassword);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域认证与JWT</title>
      <link href="/2024/03/26/%E8%B7%A8%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%B8%8EJWT/"/>
      <url>/2024/03/26/%E8%B7%A8%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%B8%8EJWT/</url>
      
        <content type="html"><![CDATA[<h3 id="跨域认证与JWT"><a href="#跨域认证与JWT" class="headerlink" title="跨域认证与JWT"></a>跨域认证与JWT</h3><h4 id="跨域认证"><a href="#跨域认证" class="headerlink" title="跨域认证"></a>跨域认证</h4><h5 id="前后端分离开发与跨域认证"><a href="#前后端分离开发与跨域认证" class="headerlink" title="前后端分离开发与跨域认证"></a>前后端分离开发与跨域认证</h5><p>在前后端分离开发中，由于前端和后端分别运行在不同的域名、端口或协议下，因此会存在跨域问题。例如：当前端向后端发起请求时，浏览器会发送一个预检请求，已检查目标站点是否允许来自该源的请求。如果目标站点允许该请求，则浏览器会将请求发送给目标站点。否则，浏览器会拒绝该请求，并在控制台中显示相应的错误信息。</p><p>为了解决跨域问题，通常需要进行跨越认证。在跨越认证中，常常使用令牌（Token）进行身份验证。例如，在使用JSON Web Token 进行用户认证后，可以将JWT令牌添加到每个请求的头部，以便服务端验证用户身份。如果令牌无效或过期，则服务端可以拒绝请求，以保护用户数据的安全性。</p><p>另外，跨域认证还可以通过CORS(跨域资源共享)机制来解决跨域问题。CORS允许Web应用程序从不同的域名或端口访问其他站点的资源。例如，如果前端站点在<a href="http://localhost:8080,而后端站点在http://localhost:8081,则可以在后端服务器中配置CORS来允许来自前端站点的跨域请求。">http://localhost:8080,而后端站点在http://localhost:8081,则可以在后端服务器中配置CORS来允许来自前端站点的跨域请求。</a></p><h5 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h5><p>JWT是指JSON Web Token,是一种用于进行身份认证和授权的开放标准，基于JSON格式的数据结构，在网络应用中被广泛使用。JWT的主要作用是在客户端和服务器之间传递安全可靠的信息。该标准定义了一种简洁的、自包含的、可扩展的方式，以JSON对象的形式在各方之间安全地传输信息。</p><p>JWT通常由三个部分组成，分别为头部（Header）、载荷（Payload）和签名（Signature）。其中，头部包含加密算法等信息，载荷包含需要传输的数据，签名用于保证数据的完整性和安全性</p><p>流程解释如下：</p><ul><li>用户向服务器发送登录请求，服务器进行身份验证。</li><li>验证成功后，服务器生成一个JWT,并将其发送给客户端</li><li>客户端将JWT保存在本地，并在后续的请求中将其发送给服务器。</li><li>服务器验证JWT的有效性，如果验证通过，则执行请求操作。</li></ul><p>JWT的优点包括：</p><ul><li>轻量级：JWT数据格式简单，传输开销小</li><li>自包含：JWT中包含了所有需要的信息，避免了每次请求时需要查询数据库等操作，提高了性能。</li><li>可扩展：JWT的格式是开放的，可以自定义添加需要的字段。</li><li>安全可靠：JWT使用签名保证数据的完整性和安全性，防止被篡改。</li></ul><h4 id="JJWT-API"><a href="#JJWT-API" class="headerlink" title="JJWT API"></a>JJWT API</h4><p>JJWT(Java JWT)是一个用于Java平台的JWT实现库，提供了JWT的创建、解析和验证功能。JWT提供了轻量级、灵活和易用的API,使得开发人员可以方便地使用JWT来实现身份验证和授权功能。</p><h4 id="JWT的使用步骤"><a href="#JWT的使用步骤" class="headerlink" title="JWT的使用步骤"></a>JWT的使用步骤</h4><ol><li><p>添加依赖</p><pre><code class="highlight java">&lt;dependency&gt;    &lt;groupId&gt;com.auth0&lt;/groupId&gt;    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;    &lt;version&gt;<span class="number">3.14</span><span class="number">.0</span>&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>编写JwtTokenService 用于生成和解析Token，用在业务层</p><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenService</span> &#123;    <span class="meta">@Value(&quot;$&#123;jwt.secret-key&#125;&quot;)</span>    <span class="keyword">private</span> String secretKey;    <span class="meta">@Value(&quot;$&#123;jwt.duration-in-minute&#125;&quot;)</span>    <span class="keyword">private</span> <span class="type">long</span> durationInMinute;    <span class="comment">/**</span><span class="comment">     * 将UserDetailsImpl对象转换为JWT字符串</span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(UserDetailsImpl userDetails)</span>&#123;        <span class="type">UserLoginInfoVO</span> <span class="variable">userLoginInfoVO</span> <span class="operator">=</span> userDetails.getUser();        <span class="keyword">return</span> createToken(userLoginInfoVO);    &#125;    <span class="comment">/**</span><span class="comment">     * 将JWT字符串解析为UserDetailsImpl对象</span><span class="comment">     */</span>    <span class="keyword">public</span> UserDetailsImpl <span class="title function_">parseJwtToken</span><span class="params">(String jwt)</span>&#123;        <span class="type">UserLoginInfoVO</span> <span class="variable">userLoginInfoVO</span> <span class="operator">=</span> parseToken(jwt);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDetailsImpl</span>(userLoginInfoVO);    &#125;    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(UserLoginInfoVO userLoginInfoVO)</span> &#123;        log.debug(<span class="string">&quot;开始创建JWT，参数：&#123;&#125;&quot;</span>, userLoginInfoVO);        <span class="comment">// 从 AdminLoginInfoVO 对象中获取数据</span>        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> userLoginInfoVO.getUsername();        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(now.getTime() + durationInMinute * <span class="number">60</span> * <span class="number">1000</span>);        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> userLoginInfoVO.getId();        <span class="type">Integer</span> <span class="variable">enabled</span> <span class="operator">=</span> userLoginInfoVO.getEnable();        <span class="type">String</span> <span class="variable">roles</span> <span class="operator">=</span> String.join(<span class="string">&quot;,&quot;</span>, userLoginInfoVO.getRoles());        <span class="type">String</span> <span class="variable">permissions</span> <span class="operator">=</span> String.join(<span class="string">&quot;,&quot;</span>, userLoginInfoVO.getPermissions());        <span class="comment">// String avatar = userLoginInfoVO.getAvatar();</span>        <span class="comment">// 创建 JWT 字符串</span>        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()                <span class="comment">// 设置 JWT 的标准信息</span>                .setSubject(subject)                .setIssuedAt(now)                .setExpiration(exp)                <span class="comment">// 设置 JWT 的载荷</span>                .claim(<span class="string">&quot;id&quot;</span>, id)                .claim(<span class="string">&quot;enabled&quot;</span>, enabled)                .claim(<span class="string">&quot;roles&quot;</span>, roles)                .claim(<span class="string">&quot;permissions&quot;</span>, permissions)                <span class="comment">// .claim(&quot;avatar&quot;, avatar)</span>                .signWith(SignatureAlgorithm.HS256, secretKey)                .compact();        log.debug(<span class="string">&quot;创建JWT成功，结果：&#123;&#125;&quot;</span>, jwt);        <span class="keyword">return</span> jwt;    &#125;    <span class="keyword">public</span> UserLoginInfoVO <span class="title function_">parseToken</span><span class="params">(String jwt)</span> &#123;        log.debug(<span class="string">&quot;开始解析JWT，参数：&#123;&#125;&quot;</span>, jwt);        <span class="keyword">try</span> &#123;            <span class="comment">// 解析 JWT 字符串</span>            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()                    .setSigningKey(secretKey)                    .parseClaimsJws(jwt)                    .getBody();            <span class="comment">// 从 JWT 字符串中获取数据</span>            <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> Long.valueOf(claims.get(<span class="string">&quot;id&quot;</span>).toString());            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> claims.get(<span class="string">&quot;sub&quot;</span>).toString();            <span class="type">Integer</span> <span class="variable">enabled</span> <span class="operator">=</span> Integer.valueOf(claims.get(<span class="string">&quot;enabled&quot;</span>).toString());            <span class="type">String</span> <span class="variable">roles</span> <span class="operator">=</span> claims.get(<span class="string">&quot;roles&quot;</span>).toString();            <span class="type">String</span> <span class="variable">permissions</span> <span class="operator">=</span> claims.get(<span class="string">&quot;permissions&quot;</span>).toString();            <span class="comment">// String avatar = claims.get(&quot;avatar&quot;).toString();</span>            <span class="comment">// 创建 UserLoginInfoVO 对象</span>            <span class="type">UserLoginInfoVO</span> <span class="variable">userLoginInfoVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserLoginInfoVO</span>();            userLoginInfoVO.setId(id);            userLoginInfoVO.setUsername(username);            userLoginInfoVO.setEnable(enabled);            userLoginInfoVO.setRoles(Arrays.asList(roles.split(<span class="string">&quot;,&quot;</span>)));            userLoginInfoVO.setPermissions(Arrays.asList(permissions.split(<span class="string">&quot;,&quot;</span>)));            <span class="comment">// userLoginInfoVO.setAvatar(avatar);</span>            log.debug(<span class="string">&quot;解析JWT成功，结果：&#123;&#125;&quot;</span>, userLoginInfoVO);            <span class="keyword">return</span> userLoginInfoVO;        &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;            log.error(<span class="string">&quot;JWT已过期&quot;</span>, e);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(ServiceCode.ERR_JWT_EXPIRED, <span class="string">&quot;JWT已过期&quot;</span>);        &#125; <span class="keyword">catch</span> (SignatureException e) &#123;            log.error(<span class="string">&quot;解析JWT失败&quot;</span>, e);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(ServiceCode.ERR_JWT_SIGNATURE, <span class="string">&quot;令牌无效&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            log.error(<span class="string">&quot;解析Token失败&quot;</span>, e);            log.error(<span class="string">&quot;解析JWT失败&quot;</span>, e);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(ServiceCode.ERR_JWT_MALFORMED, <span class="string">&quot;令牌无效&quot;</span>);        &#125;    &#125;&#125;</code></pre></li><li><p>编写JWT认证过滤器</p><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> JwtTokenService jwtTokenService;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request,</span><span class="params">                                    HttpServletResponse response,</span><span class="params">                                    FilterChain filterChain)</span>            <span class="keyword">throws</span> ServletException, IOException &#123;        <span class="comment">//获取请求头中的token</span>        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);        log.debug(<span class="string">&quot;jwtToken: &#123;&#125;&quot;</span>, jwtToken);        <span class="keyword">if</span> (jwtToken == <span class="literal">null</span>) &#123;            <span class="comment">//放行,不需要认证,不需要授权 例如登录 注册 验证码等</span>            filterChain.doFilter(request, response);            <span class="keyword">return</span>;        &#125;        <span class="keyword">try</span> &#123;            <span class="comment">//从token中获取用户信息</span>            <span class="type">UserDetailsImpl</span> <span class="variable">userDetails</span> <span class="operator">=</span> jwtTokenService.parseJwtToken(jwtToken);            log.debug(<span class="string">&quot;userDetails: &#123;&#125;&quot;</span>, userDetails);            <span class="comment">//将用户信息存入SecurityContext</span>            <span class="comment">//创建UsernamePasswordAuthenticationToken对象作为认证结果</span>            <span class="type">Authentication</span> <span class="variable">authenticationResult</span> <span class="operator">=</span>                    <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(                            userDetails,                            <span class="literal">null</span>,                            userDetails.getAuthorities());            <span class="comment">// 将UsernamePasswordAuthenticationToken存入SecurityContext</span>            <span class="comment">// 从而完成利用Token认证</span>            SecurityContextHolder.getContext().setAuthentication(authenticationResult);            <span class="comment">//放行</span>            filterChain.doFilter(request, response);        &#125;<span class="keyword">catch</span> (ServiceException e)&#123;            <span class="comment">//token无效</span>            log.debug(<span class="string">&quot;token无效&quot;</span>);            <span class="comment">//响应错误信息</span>            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);            JsonResult&lt;Void&gt; jsonResult = JsonResult.fail(e);            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> jsonResult.toJson();            response.getWriter().println(json);        &#125;    &#125;&#125;</code></pre></li><li><p>编写JWT认证失败处理器</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * JWT 认证失败处理器（解决客户端403错误）</span><span class="comment"> * 1.未登录时访问受保护的资源</span><span class="comment"> * 2.认证过程中出现异常</span><span class="comment"> * 3.认证成功 但是访问受保护的资源权限不足</span><span class="comment"> */</span><span class="meta">@Component</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest httpServletRequest,</span><span class="params">                         HttpServletResponse httpServletResponse,</span><span class="params">                         AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;        log.debug(<span class="string">&quot;JwtTokenAuthenticationEntryPoint.commence() &#123;&#125;&quot;</span>, e.getMessage());        httpServletResponse.setStatus(HttpServletResponse.SC_OK);        httpServletResponse.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);        JsonResult&lt;Void&gt; result = JsonResult.fail(ServiceCode.ERR_UNAUTHORIZED, <span class="string">&quot;请登录后再访问&quot;</span>);        httpServletResponse.getWriter().println(result.toJson());    &#125;&#125;</code></pre></li><li><p>在Web资源授权过滤器中配置</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="meta">@EnableWebSecurity</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> JwtTokenAuthenticationEntryPoint jwtTokenAuthenticationEntryPoint;    <span class="comment">/**</span><span class="comment">     * 管理 AuthenticationManager</span><span class="comment">     * <span class="doctag">@param</span> config AuthenticationConfiguration</span><span class="comment">     * <span class="doctag">@return</span> 认证管理器</span><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span><span class="comment">     */</span>    <span class="meta">@Bean</span>    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(</span><span class="params">            AuthenticationConfiguration config)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">return</span> config.getAuthenticationManager();    &#125;    <span class="comment">/**</span><span class="comment">     * 配置跨域认证</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Bean</span>    CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span>&#123;        <span class="type">CorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);<span class="comment">//同源配置，*表示任何请求都视为同源，若需指定ip和端口可以改为如“localhost：8080”，多个以“，”分隔；</span>        corsConfiguration.addAllowedHeader(<span class="string">&quot;Authorization&quot;</span>);<span class="comment">//header，允许哪些header，本案中使用的是token，此处可将*替换为token；</span>        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许的请求方法，PSOT、GET等</span>        ((UrlBasedCorsConfigurationSource) source).registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration); <span class="comment">//配置允许跨域访问的url</span>        <span class="keyword">return</span> source;    &#125;    <span class="comment">/**</span><span class="comment">     * 设置URL授权管理</span><span class="comment">     * <span class="doctag">@param</span> http</span><span class="comment">     * <span class="doctag">@throws</span> Exception</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 放行清单</span>        String[] permitList = &#123;                <span class="string">&quot;/favicon.ico&quot;</span>,     <span class="comment">// 网站图标文件</span>                <span class="string">&quot;/&quot;</span>,                <span class="comment">// 根页面，通常是主页</span>                <span class="string">&quot;/*.html&quot;</span>,          <span class="comment">// 任何html</span>                <span class="string">&quot;/**/*.html&quot;</span>,       <span class="comment">// 任何目录下的html</span>                <span class="string">&quot;/**/*.css&quot;</span>,        <span class="comment">// 任何目录下的css</span>                <span class="string">&quot;/**/*.js&quot;</span>,         <span class="comment">// 任何目录下的js</span>                <span class="string">&quot;/auth/login&quot;</span>,     <span class="comment">// 登录</span>                <span class="string">&quot;/auth/logout&quot;</span>,    <span class="comment">// 登录</span>                <span class="string">&quot;/users/register&quot;</span>   <span class="comment">// 注册</span>        &#125;;        <span class="comment">// 禁止跨域请求伪造过滤器</span>        http.csrf().disable();        http.cors().configurationSource(corsConfigurationSource());        <span class="comment">// Session管理</span>        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);        http.sessionManagement().sessionFixation().none();        <span class="comment">// 认证规则</span>        http.authorizeRequests()                .antMatchers(permitList).permitAll()                .anyRequest().authenticated();        <span class="comment">//未认证处理器</span>        http.exceptionHandling().authenticationEntryPoint(jwtTokenAuthenticationEntryPoint);        <span class="comment">// 添加自定义过滤器</span>        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);    &#125;&#125;</code></pre></li><li><p>业务层实现类代码</p><pre><code class="highlight java"><span class="keyword">public</span> JwtVO <span class="title function_">login</span><span class="params">(AdminLoginInfoDTO adminLoginInfoDTO)</span> &#123;    <span class="comment">//1.创建认证对象,传入用户名和密码</span>    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span>            <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(                    adminLoginInfoDTO.getUsername(),                    adminLoginInfoDTO.getPassword()            );    <span class="comment">//调用认证管理器的方法传入认证对象(传入用户名和密码)</span>    <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(token);    <span class="comment">//如果认证成功,把认证信息传入上下文对象(SecurityContext) 对象的作用范围:服务器不关闭就一直存在</span>    <span class="comment">//如果没有存储信息 说明认证失败</span>    SecurityContextHolder.getContext().setAuthentication(authenticate);    <span class="comment">//获取认证的主体</span>    <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> authenticate.getPrincipal();    <span class="comment">//认证的主体是UserDetails的实现类 UserDetailsImpl类的对象</span>    <span class="type">UserDetailsImpl</span> <span class="variable">userDetails</span> <span class="operator">=</span> (UserDetailsImpl) principal;    <span class="comment">// 认证成功 生成token</span>    <span class="type">String</span> <span class="variable">tokenString</span> <span class="operator">=</span> jwtTokenService.createToken(userDetails);    <span class="comment">//把Token返回给客户端</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtVO</span>(tokenString);&#125;</code></pre></li><li><p>控制层代码</p></li></ol><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">   * 管理员登录</span><span class="comment">   * <span class="doctag">@param</span> adminLoginInfoDTO</span><span class="comment">   * <span class="doctag">@return</span></span><span class="comment">   */</span>  <span class="meta">@PostMapping(&quot;/login&quot;)</span>  <span class="keyword">public</span> JsonResult&lt;JwtVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> AdminLoginInfoDTO adminLoginInfoDTO)</span>&#123;      log.info(<span class="string">&quot;开始处理[管理员登录]的请求,参数:&#123;&#125;&quot;</span>,adminLoginInfoDTO);      <span class="type">JwtVO</span> <span class="variable">token</span> <span class="operator">=</span> adminService.login(adminLoginInfoDTO);      <span class="comment">//将生成的Token返回给客户端</span>      <span class="keyword">return</span> JsonResult.ok(token);  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话状态和过滤器</title>
      <link href="/2024/03/26/%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2024/03/26/%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="会话状态和过滤器"><a href="#会话状态和过滤器" class="headerlink" title="会话状态和过滤器"></a>会话状态和过滤器</h3><h4 id="web应用中的安全"><a href="#web应用中的安全" class="headerlink" title="web应用中的安全"></a>web应用中的安全</h4><p>在探讨web应用安全时，必须认识到<strong>认证功能、</strong>s<strong>ession和Filter之间的紧密联系。</strong></p><p>认证功能是指对用户进行身份验证的过程，通常涉及用户名、密码等信息的验证。在web应用中，我们一般采用基于表单的认证方式。用户在登录页面输入凭证，系统会验证这些信息。认证成功后，用户信息常常会被存储在Session中，这样就能在后续的操作中用于权限校验等需要</p><p>Session是Web应用中常见的一种机制，用于在客户端和服务器端之间保存状态信息。在认证成功后，用户的身份信息通常会被存储在Session中。当客户端发起请求时，服务器可以通过session中的信息识别用户的身份，从而授权或拒绝请求。</p><p>Filter是Web应用中非常重要的组件，它负责拦截和处理请求。在认证中，filter经常被用来实现身份验证的功能。它能够拦截请求，并根据session中的信息对请求进行身份校验。如果身份校验失败，filter可以拒绝请求或将用户重新导向登录页面。</p><p><strong>Session和Filter是构建web应用安全性的三大核心部分。通过认证验证用户身份并将其信息存储在Session中，Filter可以根据Session中的信息进行身份校验和请求拦截，从而确保Web应用的安全性</strong>。</p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>Cookies是一种用于在web浏览器和Web服务器之间传递数据的技术。他可以在客户端存储一些数据，然后在之后的请求中将这些数据传递给服务器。Cookies通常被用来记录用户的会话信息、个性化设置和其他用户偏好等。</p><p>在网站中，当用户登录成功后，服务器会通过设置Cookies来给用户分配一个唯一的标识码，这个标识码会被保存在用户的浏览器中。在用户下一次访问该网站时，浏览器会自动带上这个标识码，服务器就可以通过这个标识码识别出用户身份，从而为用户提供个性化的服务。这种方式解决了Web应用程序无法识别用户身份的问题，使得用户可以更加方便地访问网站，提高了用户体验</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session是指在客户端与服务器交互时，用于存储特定用户会话信息的一种机制。在Web应用中，Session可以用来存储用户的登录状态、购物车内容、用户偏好等数据，以便在用户浏览网站的不同页面或者多次请求时保持一致。使用Session技术来区分不同的用户</p><p>Session和Cookies是Web应用中两个常用的技术，它们之间有着紧密的关系</p><p>Cookies技术可以在客户端（浏览器）存储一些数据，并且在后续的请求中将这些数据带上，以便服务器能够识别客户端身份。而Session技术则是在服务器端存储一些数据，用于标识客户端身份和维护客户端状态。<strong>Session ID通常是通过Cookies技术下发给客户端的</strong>。</p><p>当客户端发送请求时，服务器可以从请求中获取Cookies中的Session ID,然后根据这个Session ID从服务器端的Session存储中获取对应的Session数据，从而维护客户端状态。</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器也称为Servlet过滤器，是java Servlet API的一部分<strong>，用于在请求到达Web应用程序的目标资源之前，对请求进行预处理和后处理</strong>。过滤器在Web应用程序中配置，并按照声明的顺序链接起来，形成一个过滤器链。</p><p>过滤器可以对请求和响应进行修改、转换和拦截，例如：在请求到达目标资源之前，检查用户是否有权限访问该资源，或者 在响应发送到客户端之前，对响应就行压缩或加密。</p><p>过滤器还可以用于记录请求信息、进行数据验证、设置字符编码、添加HTTP头信息等。它们是Web应用程序中实现通用业务逻辑和安全性的一种灵活而有用的工具。</p><h4 id="过滤器API"><a href="#过滤器API" class="headerlink" title="过滤器API"></a>过滤器API</h4><p>Servlet过滤器是Java Web应用中用于拦截HTTP请求和响应的组件，可以在请求到达Servlet之前或者响应离开Servlet之前对请求和响应进行预处理、后处理和过滤</p><p>Filter接口： 所有过滤器都必须实现该接口。Filter接口定义了三个方法：</p><ol><li>init()方法：初始化过滤器，在容器启动时执行，仅执行一次</li><li>doFilter()方法：处理请求和响应，执行过滤器的核心逻辑</li><li>destroy()方法：销毁过滤器，在容器关闭时执行，仅执行一次。</li></ol><p>FilterChain接口：用于传递请求和响应给过滤器链中的下一个过滤器或Servlet。FilterChain接口定义了一个方法：</p><ol><li>doFilter(ServletRequest request,ServletResponse response):传递请求和响应给下一个过滤器或Servlet</li></ol><h4 id="过滤器工作原理"><a href="#过滤器工作原理" class="headerlink" title="过滤器工作原理"></a>过滤器工作原理</h4><p>1、客户端发送HTTP请求到服务器，服务器接收请求并将其传递到Web容器，Web容器根据请求路径匹配相应的过滤器，并将请求传递给第一个过滤器；</p><p>2、过滤器执行自己的逻辑，如验证请求参数、检查用户登录状态、添加头信息等，然后决定是否将请求继续传递给下一个过滤器；</p><p>3、如果当前过滤器决定将请求传递给下一个过滤器，则调用FilterChain对象的doFilter()方法将请求传递给下一个过滤器，如果当前过滤器是最后一个过滤器，则直接将请求传递给Servlet；</p><p>4、Web容器出来后续资源，生成响应结果并将其传回给过滤器；</p><p>5、过滤器执行自己的逻辑，修改响应结果；</p><p>6、最后将响应返回给客户端。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security对接到RBAC</title>
      <link href="/2024/03/26/Spring-Security%E5%AF%B9%E6%8E%A5%E5%88%B0RBAC/"/>
      <url>/2024/03/26/Spring-Security%E5%AF%B9%E6%8E%A5%E5%88%B0RBAC/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Security对接到RABC"><a href="#Spring-Security对接到RABC" class="headerlink" title="Spring Security对接到RABC"></a>Spring Security对接到RABC</h3><h4 id="RBAC数据提供给Spring-Security"><a href="#RBAC数据提供给Spring-Security" class="headerlink" title="RBAC数据提供给Spring Security"></a>RBAC数据提供给Spring Security</h4><h4 id="对接原理"><a href="#对接原理" class="headerlink" title="对接原理"></a>对接原理</h4><p>在RBAC系统中，将RBAC的用户和权限数据提供给Spring Security是一个关键的步骤，以便Spring Security可以进行认证和授权。这一部分描述了如何通过RBAC来实现UserDetailsService和UserDetails接口，为Spring Security提供认证数据的原理和实际操作。</p><p>RBAC系统存储了用户、角色和权限的数据，而Spring Security需要这些信息进行认证和授权。为了对接这两者，我们可以实现UserDetailsService接口，以便Spring Security能够获取用户信息</p><h4 id="以下是具体的实现步骤，只做参考，需要根据具体的程序进行相应的修改"><a href="#以下是具体的实现步骤，只做参考，需要根据具体的程序进行相应的修改" class="headerlink" title="以下是具体的实现步骤，只做参考，需要根据具体的程序进行相应的修改"></a>以下是具体的实现步骤，只做参考，需要根据具体的程序进行相应的修改</h4><ol><li><p>为了提供Spring Security所需的信息，首先定义一个专门提供这些信息的VO对象，AdminLoginInfoVO,包括用户名、密码以及角色和权限信息</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 管理员的登录信息的VO类</span><span class="comment">* <span class="doctag">@author</span> java@tedu.cn</span><span class="comment"> * <span class="doctag">@version</span> 0.0.1</span><span class="comment"> */</span><span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminLoginInfoVO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;    <span class="comment">/* 数据ID */</span>    <span class="keyword">private</span> Long id;    <span class="comment">/* 用户名 */</span>    <span class="keyword">private</span> String username;    <span class="comment">/* 密码（密文）*/</span>    <span class="keyword">private</span> String password;    <span class="comment">/* 是否启用，1=启用，0=禁用 */</span>    <span class="keyword">private</span> Integer enable;    <span class="comment">/* 权限列表 */</span>    <span class="keyword">private</span> List&lt;String&gt; permissions;    <span class="comment">/* 角色列表 */</span>    <span class="keyword">private</span> List&lt;String&gt; roles;&#125;</code></pre></li><li><p>在Mapper接口中定义方法用于根据用户名查询管理员的登录信息</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 根据用户名查询管理员的登录信息</span><span class="comment"> * <span class="doctag">@param</span> username 用户名</span><span class="comment"> * <span class="doctag">@return</span> 匹配的登录信息，如果没有匹配的数据，则返回null</span><span class="comment"> */</span>AdminLoginInfoVO <span class="title function_">getLoginInfoByUsername</span><span class="params">(String username)</span>;</code></pre></li><li><p>实现UserDetails接口</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 封装登录管理员的信息</span><span class="comment"> */</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> AdminLoginInfoVO admin;    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 定义构造方法 封装角色和权限</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">UserDetailsImpl</span><span class="params">(AdminLoginInfoVO admin)</span>&#123;        <span class="built_in">this</span>.admin = admin;        <span class="comment">//读取角色和权限</span>        List&lt;String&gt; roles = admin.getRoles();        List&lt;String&gt; permissions = admin.getPermissions();        <span class="comment">//把角色和权限封装到authorities中</span>        <span class="keyword">if</span> (roles != <span class="literal">null</span>)&#123;            <span class="keyword">for</span> (String role:roles)&#123;                <span class="comment">//角色是以&quot;ROLE_&quot;为前缀</span>                authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_&quot;</span>+role));            &#125;        &#125;        <span class="keyword">if</span> (permissions !=<span class="literal">null</span>)&#123;            <span class="keyword">for</span> (String permission:permissions)&#123;                authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(permission));            &#125;        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回角色和权限</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;        <span class="keyword">return</span> authorities;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回密码</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;        <span class="keyword">return</span> admin.getPassword();    &#125;    <span class="comment">/**</span><span class="comment">     * 返回用户名</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;        <span class="keyword">return</span> admin.getUsername();    &#125;    <span class="comment">/**</span><span class="comment">     * 返回false 表示用户过期</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回false表示用户被锁定(例如3次错误密码锁定账户)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回false表示凭证过期</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回false表示禁用</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;&#125;</code></pre></li><li><p>实现UserDetailsService接口</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 查询管理员信息</span><span class="comment"> */</span><span class="meta">@Service</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> AdminMapper adminMapper;    <span class="meta">@Override</span>    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;        log.info(<span class="string">&quot;Spring Security查询用户信息,参数:&#123;&#125;&quot;</span>,username);        <span class="type">AdminLoginInfoVO</span> <span class="variable">adminLoginInfoVO</span> <span class="operator">=</span> adminMapper.getLoginInfoByUsername(username);        <span class="keyword">if</span> (adminLoginInfoVO !=<span class="literal">null</span>)&#123;            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDetailsImpl</span>(adminLoginInfoVO);        &#125;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名不存在&quot;</span>);    &#125;&#125;</code></pre></li><li><p>开启对方法授权</p></li></ol><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="meta">@EnableMethodSecurity</span><span class="comment">//开启方法访问授权</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security安全框架</title>
      <link href="/2024/03/26/Spring-Security%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/03/26/Spring-Security%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Security安全框架"><a href="#Spring-Security安全框架" class="headerlink" title="Spring Security安全框架"></a>Spring Security安全框架</h3><h4 id="什么是Spring-Security"><a href="#什么是Spring-Security" class="headerlink" title="什么是Spring Security"></a>什么是Spring Security</h4><p>手工编写身份验证和授权功能非常繁琐，但是Spring Security可以帮助我们简化认证和授权的实现。Spring Security是一个基于Spring框架的开源框架，其提供了一系列的功能用于保护Java Web应用程序，防止未经授权的访问。它的目标是简化安全开发，同时提供了丰富的配置和选项以满足不同的安全需求。S<strong>pring Security的主要工能包括身份验证和授权、安全性控制、认证和授权管理器、安全上下文、拦截器等,这些功能可以使开发人员更轻松地保护他们的应用程序</strong>。但是<strong>，Spring Security提供饿了身份验证和授权的功能，但是不提供身份验证和授权信息的存储，业务规则处理等，因此需要使用数据库等系统提供的数据存储进行支持，例如采用RBAC的数据库</strong>。</p><h4 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h4><p>认证和授权是安全领域中两个重要的概念。认证是确定用户、设备或系统的身份是否真实过程，授权则是决定哪些身份可以访问哪些资源的过程。</p><p>在认证过程中，用户提交自己的身份信息进行验证，验证成功后会生成一个代表身份的凭证（如令牌或票据），该凭证被称为“身份验证”。身份验证通常需要使用密码、证书、生物识别等方式进行。</p><p>在授权过程中，系统会检查某个身份是否拥有访问某项资源的权限，这些权限可以是角色、操作权限等。如果身份具备相应的权限，则可以访问该资源。</p><h4 id="认证和授权的概念："><a href="#认证和授权的概念：" class="headerlink" title="认证和授权的概念："></a>认证和授权的概念：</h4><ul><li>Principal（当事人）：执行动作的用户、设备或系统</li><li>Authentication(认证)：确定当事人的认证是否有效</li><li>Authorization(授权)：决定是否允许某个当事人访问某项资源</li><li>Authority(资源)：允许访问的权限或凭证（如角色）</li><li>Secured Resource(保护资源)：受保护的资源</li></ul><p>Spring Security的认证Authentication:</p><ul><li>支持多种认证机制：例如基本认证、摘要认证、表单认证、X.509认证、OAuth认证</li><li>认证和授权数据有许多可选的存储方案：例如内存中（开发时）、数据库、LDAP</li></ul><p>Spring Secutriry的授权Authorization:</p><ul><li>授权是基于认证的结果，也就是在决定一个用户是否被允许访问一个资源之前，必须确定用户身份</li><li>授权决定了你是否具有必要的权限，决策过程通常是基于角色的，例如：ADMIN角色可以取消订单，MEMBER角色可以下订单，GUEST角色可以浏览目录</li><li>Spring Security不提供存储方案，比如使用RBAC方案</li></ul><h4 id="Spring-Boot中使用Spring-Security的步骤"><a href="#Spring-Boot中使用Spring-Security的步骤" class="headerlink" title="Spring Boot中使用Spring Security的步骤"></a>Spring Boot中使用Spring Security的步骤</h4><ol><li><p>在pom.xml文件中添加相关依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre></li><li><p>配置安全规则</p></li></ol><p>Spring Security配置可以分为两个主要方面：认证规则和授权规则</p><p>认证规则确定了用户如何登录到应用程序。你可以配置基本的用户名和密码认证规则，也可以定义自定义认证规则。</p><p>授权规则决定了哪些用户可以访问应用程序的哪些部分。这包括Web请求的授权和方法级别的授权。</p><p>配置完认证规则和授权规则后，Spring Security会处理用户的登录和访问权限。</p><h4 id="提供数据进行认证"><a href="#提供数据进行认证" class="headerlink" title="提供数据进行认证"></a>提供数据进行认证</h4><p>Spring Security提供了基于程序提供的认证数据存储方式，需要用户实现UserDetailsService接口和UserDetails接口。其中，<strong>UserDetailsService接口用于获取用户的认证信息，UserDetails接口则用于描述用户的具体信息，如用户名、密码、用户角色等等。通过实现这两个接口，就可以根据自己的需求来获取和描述认证数据，并与Spring Security进行集成</strong>，实现用户认证和授权功能。值得注意的是，由于Spring Security没有提供自带的认证数据存储方案，因此需要用户自己实现这些接口来获取和存储认证数据。</p><p>UserDetials实现类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUserDetails</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;tom&quot;</span>;    <span class="comment">// 密码是 1234</span>    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&#123;bcrypt&#125;$2a$10$Y9Fer2InTmzomIakxG2aEuKab.YIMp8mdIXtTsWjwq0OjXkL6Rkia&quot;</span>;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;        <span class="keyword">return</span> username;    &#125;    <span class="comment">/**</span><span class="comment">     * 以下方法返回false，表示用户已过期</span><span class="comment">     * <span class="doctag">@return</span> true</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 以下方法返回false，表示用户不被锁定</span><span class="comment">     * <span class="doctag">@return</span> true</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 以下方法返回false，表示用户凭证已过期</span><span class="comment">     * <span class="doctag">@return</span> true</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 以下方法返回false，表示用户不可用</span><span class="comment">     * <span class="doctag">@return</span> true</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 以下方法返回null，表示用户没有任何权限</span><span class="comment">     * <span class="doctag">@return</span> null</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;        <span class="keyword">return</span> password;    &#125;&#125;</code></pre><p>UserDetailsService实现类</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;    <span class="comment">/**</span><span class="comment">     * 根据用户名查询用户详情</span><span class="comment">     * <span class="doctag">@param</span> username 用户名</span><span class="comment">     * <span class="doctag">@return</span> 用户详情</span><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException 用户名未找到异常</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;        <span class="keyword">if</span> (<span class="string">&quot;tom&quot;</span>.equals(username)) &#123;            log.debug(<span class="string">&quot;用户名 tom 找到了&quot;</span>);            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestUserDetails</span>();        &#125;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名 &quot;</span> + username + <span class="string">&quot; 没找到&quot;</span>);    &#125;&#125;</code></pre><h4 id="Spring-Security方法授权"><a href="#Spring-Security方法授权" class="headerlink" title="Spring Security方法授权"></a>Spring Security方法授权</h4><p>Spring Security的授权功能用于管理用户对资源的权限，它基于角色和权限来控制对方法和Web资源的访问。通过授权，你可以限制用户对受保护资源的访问，并且可以根据用户的角色和权限级别进行细粒度的控制。Spring Security的授权功能构建在一系列授权过滤器之上，使得配置和扩展变得非常灵活。通过配置授权规则，你可以为不同用户角色分配不同的权限从而实现对资源的精细控制。</p><ol><li><p>添加角色和权限</p><p>需要在TestUserDetails中为用户”tom”添加测试角色和权限。在这个示例中，”tom”用户被赋予了”ADMIN”和”USER”两个角色，以及”sys:log:query”和”sys:log:add”两个权限：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 以下方法返回null，表示用户没有任何权限</span><span class="comment"> * 测试用户 Tom 拥有 ADMIN USER 两个角色，sys:log:query 和 sys:log:add 两个权限</span><span class="comment"> * <span class="doctag">@return</span> 权限集合</span><span class="comment"> */</span><span class="meta">@Override</span><span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;    List&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">// 添加测试角色 ADMIN USER</span>    authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_ADMIN&quot;</span>));    authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_USER&quot;</span>));    <span class="comment">//添加测试权限，查询和添加日志</span>    authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;sys:log:query&quot;</span>));    authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;sys:log:add&quot;</span>));    <span class="keyword">return</span> authorities;&#125;</code></pre></li><li><p>方法角色授权 </p><p>Spring Security 提供方法级别的角色授权，用于保护应用程序中的方法，以防止未经授权的访问。通过在方法级别配置角色授权，你可以确保只有拥有特定角色的用户才能访问受保护的方法。这有助于保护应用程序中的关键功能和数据，确保只有授权用户可以访问和修改</p><pre><code class="highlight java"><span class="meta">@Configuration</span><span class="meta">@EnableMethodSecurity</span> <span class="comment">//开启方法访问授权 5.7版本之后</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;&#125;<span class="meta">@Configuration</span><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span> <span class="comment">//开启方法访问授权 5.7版本之前</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> &#123;&#125;</code></pre></li><li><p>实现方法角色授权</p><p>在示例中，我们有一个LogService业务类，包含两个方法：adminLog和managerLog。我们为这两个方法分别分配了”ADMIN”和”MANAGER”角色的访问权限。这意味着只有拥有这些角色的用户才能访问这些方法：</p><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogService</span> &#123;    <span class="comment">/**</span><span class="comment">     * 管理员日志方法，必须具有管理员角色才能访问</span><span class="comment">     * <span class="doctag">@PreAuthorize</span>(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;) 用于方法访问授权</span><span class="comment">     * hasRole 检查是否具有指定角色，不需要加前缀 ROLE_</span><span class="comment">     */</span>    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adminLog</span><span class="params">()</span> &#123;        log.debug(<span class="string">&quot;管理员日志方法&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 经理日志方法，必须具有经理角色才能访问</span><span class="comment">     * <span class="doctag">@PreAuthorize</span>(&quot;hasRole(&#x27;MANAGER&#x27;)&quot;) 用于方法访问授权</span><span class="comment">     * hasRole 检查是否具有指定角色，不需要加前缀 ROLE_</span><span class="comment">     */</span>    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;MANAGER&#x27;)&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">managerLog</span><span class="params">()</span> &#123;        log.debug(<span class="string">&quot;经理日志方法&quot;</span>);    &#125;&#125;</code></pre><p>然后，我们在控制器中定义了两个访问入口，分别对应adminLog和managerLog方法。这些入口会验证用户的角色，确保只有拥有相应角色的用户才能访问：</p><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> LogService logService;    <span class="comment">/**</span><span class="comment">     * 请求 /admin/log 时，必须具有 ADMIN 角色才能访问</span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/admin/log&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">adminLog</span><span class="params">()</span> &#123;        log.debug(<span class="string">&quot;请求 /admin/log&quot;</span>);        logService.adminLog();        <span class="keyword">return</span> <span class="string">&quot;admin log&quot;</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 请求 /manager/log 时，必须具有 MANAGER 角色才能访问</span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/manager/log&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">managerLog</span><span class="params">()</span> &#123;        log.debug(<span class="string">&quot;请求 /manager/log&quot;</span>);        logService.managerLog();        <span class="keyword">return</span> <span class="string">&quot;manager log&quot;</span>;    &#125;&#125;</code></pre></li><li><p>方法权限授权</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 具有日志查询权限的才能访问当前query方法</span><span class="comment"> */</span><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;sys:log:query&#x27;)&quot;)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryList</span><span class="params">()</span> &#123;    log.debug(<span class="string">&quot;日志查询方法&quot;</span>);&#125;<span class="comment">/**</span><span class="comment"> * 具有日志删除权限的才能访问当前delete方法</span><span class="comment"> */</span><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;sys:log:delete&#x27;)&quot;)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;    log.debug(<span class="string">&quot;日志删除方法&quot;</span>);&#125;</code></pre></li></ol><h4 id="Web资源授权"><a href="#Web资源授权" class="headerlink" title="Web资源授权"></a>Web资源授权</h4><p>Spring Security提供了Web资源保护功能，它通过一系列的Web过滤器来实现。这些过滤器可以拦截所有的Web请求，并根据配置来进行安全处理，例如用户身份认证、角色和权限验证、跨站请求伪造保护等。通过配置这些过滤器，开发者可以轻松地为Web应用程序添加安全保护</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RBAC基于角色的访问控制</title>
      <link href="/2024/03/26/RBAC%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/03/26/RBAC%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="RBAC基于角色的访问控制"><a href="#RBAC基于角色的访问控制" class="headerlink" title="RBAC基于角色的访问控制"></a>RBAC基于角色的访问控制</h3><h4 id="RBAC数据库设计"><a href="#RBAC数据库设计" class="headerlink" title="RBAC数据库设计"></a>RBAC数据库设计</h4><p>Spring Security 提供了认证和授权功能，但仅提供了测试数据存储，没有提供完整的认证信息存储。这种设计的好处是可以灵活适配各种认证存储方案，例如LDAP、数据库、RBAC等。在这里，我们将采用RBAC方案作为示例。</p><p>RBAC（Role-Based Access Control），即基于角色的访问控制，是计算机安全领域广泛应用的访问控制模型。它通过将权限控制操作从个体用户转移到角色实体，提高了系统的安全性和可管理性。</p><p>RBAC的基本概念包括用户、角色、权限和许可。用户是系统的使用者，角色是对用户进行分类的一组权限集合，权限是对资源的访问权利，许可指的是角色被授予的权限使用范围。</p><p>在RBAC模型中，每个用户被分配到一个或多个角色，每个角色拥有特定的权限，用户通过角色间接地访问资源。这种机制使得管理和授权变得更加简单，管理员只需为角色分配权限，而不是为每个用户分配权限。</p><p>RBAC的优点包括易于管理和扩展，提高了系统的安全性和可维护性。然而，RBAC也具有一定的局限性，例如不够灵活，难以处理复杂的权限控制需求等。因此，在实际应用中，RBAC模型需要根据具体场景进行灵活的设计和调整。</p><p>Spring Security提供了基于角色和权限的访问控制，可以轻松地实现RBAC模型。Spring Security是一个可定制的框架，允许使用任意权限控制模型</p><p>RABC系统功能</p><h4 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h4><p>在涉及权限管理员的软件设计中，应该至少需要设计以下3张数据表：</p><ul><li>账号表（也可成为管理员表或用户表）：ams_admin:用于记录管理员的账号信息</li><li>角色表：ams_role，与账号表关联，并于权限表关联</li><li>权限表：ams_permission,用于记录系统中的所有权限（权限标识）。</li></ul><h4 id="实现RBAC业务功能"><a href="#实现RBAC业务功能" class="headerlink" title="实现RBAC业务功能"></a>实现RBAC业务功能</h4><p>实现RBAC的方案通常需要涉及用户管理、角色管理、权限管理等模块的开发。用户管理模块用于管理系统中的用户，包括用户的增加、删除、修改和查询等功能。角色管理模块用于管理系统中的角色，包括角色的增加、删除、修改和查询等功能。权限管理模块用于管理系统中的权限，包括权限的增加、删除、修改和查询等功能。这些模块可以通过MyBatis访问数据库，并利用业务层完成数据的处理和转换，通过POJO类型的VO、DTO、Entity进行传输。</p><p>在实现RBAC的方案中，需要将用户信息和角色信息与Spring Security的安全框架进行对接。这可以通过实现UserDetailsService接口和UserDetails接口来完成。UserDetailsService接口用于从数据源中加载用户信息，并将其封装为UserDetails对象；UserDetails接口用于封装用户的认证信息和授权信息，其中包括用户名、密码、角色列表等信息。通过对接UserDetailsService和UserDetails接口，可以将RBAC的角色授权信息与Spring Security的安全框架相结合，实现对系统中资源的访问控制</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JsonResult_execption</title>
      <link href="/2024/03/26/JsonResult-execption/"/>
      <url>/2024/03/26/JsonResult-execption/</url>
      
        <content type="html"><![CDATA[<h4 id="JsonResult"><a href="#JsonResult" class="headerlink" title="JsonResult"></a>JsonResult</h4><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 统一响应结果类型</span><span class="comment"> */</span><span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonResult</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;    <span class="keyword">private</span> Integer code;    <span class="keyword">private</span> String message;    <span class="keyword">private</span> T data; <span class="comment">// E &gt; Element / K &gt; Key / V &gt; Value / T &gt; Type</span>    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult&lt;Void&gt; <span class="title function_">ok</span><span class="params">()</span> &#123;        <span class="keyword">return</span> ok(<span class="literal">null</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; JsonResult&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span> &#123;        JsonResult&lt;T&gt; jsonResult = <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;();        jsonResult.setCode(ServiceCode.OK.getValue());        jsonResult.setData(data);        jsonResult.message = <span class="string">&quot;OK&quot;</span>;        <span class="keyword">return</span> jsonResult;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult&lt;Void&gt; <span class="title function_">fail</span><span class="params">(ServiceException e)</span> &#123;        <span class="keyword">return</span> fail(e.getServiceCode(), e.getMessage());    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult&lt;Void&gt; <span class="title function_">fail</span><span class="params">(ServiceCode serviceCode, String message)</span> &#123;        JsonResult&lt;Void&gt; jsonResult = <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;();        jsonResult.setCode(serviceCode.getValue());        jsonResult.setMessage(message);        <span class="keyword">return</span> jsonResult;    &#125;    <span class="comment">/**</span><span class="comment">     * 将当前对象转换为JSON字符串</span><span class="comment">     * <span class="doctag">@return</span> 当前对象的JSON字符串表示</span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">toJson</span><span class="params">()</span> &#123;        <span class="keyword">try</span> &#123;            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(<span class="built_in">this</span>);        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;            e.printStackTrace();            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;    &#125;&#125;</code></pre><p>异常类</p><h4 id="枚举业务状态码枚举类型"><a href="#枚举业务状态码枚举类型" class="headerlink" title="枚举业务状态码枚举类型"></a>枚举业务状态码枚举类型</h4><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 业务状态码枚举类型</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@author</span> lifuteng</span><span class="comment"> * <span class="doctag">@version</span> 0.0.1</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ServiceCode</span> &#123;    <span class="comment">/**</span><span class="comment">     * 成功</span><span class="comment">     */</span>    OK(<span class="number">20000</span>),    <span class="comment">/**</span><span class="comment">     * 错误：请求参数格式有误</span><span class="comment">     */</span>    ERR_BAD_REQUEST(<span class="number">40000</span>),    <span class="comment">/**</span><span class="comment">     * 错误：登录失败，用户名或密码错</span><span class="comment">     */</span>    ERR_UNAUTHORIZED(<span class="number">40100</span>),    <span class="comment">/**</span><span class="comment">     * 错误：登录失败，账号被禁用</span><span class="comment">     */</span>    ERR_UNAUTHORIZED_DISABLED(<span class="number">40101</span>),    <span class="comment">/**</span><span class="comment">     * 错误：无权限</span><span class="comment">     */</span>    ERR_FORBIDDEN(<span class="number">40300</span>),    <span class="comment">/**</span><span class="comment">     * 错误：数据不存在</span><span class="comment">     */</span>    ERR_NOT_FOUND(<span class="number">40400</span>),    <span class="comment">/**</span><span class="comment">     * 错误：数据冲突</span><span class="comment">     */</span>    ERR_CONFLICT(<span class="number">40900</span>),    <span class="comment">/**</span><span class="comment">     * 错误：数据冲突，已经存在</span><span class="comment">     */</span>    ERR_EXISTS(<span class="number">40901</span>),    <span class="comment">/**</span><span class="comment">     * 错误：数据冲突，已经关联</span><span class="comment">     */</span>    ERR_IS_ASSOCIATED(<span class="number">40902</span>),    <span class="comment">/**</span><span class="comment">     * 错误：插入数据错误</span><span class="comment">     */</span>    ERR_SAVE_FAILED(<span class="number">50000</span>),    <span class="comment">/**</span><span class="comment">     * 错误：删除数据错误</span><span class="comment">     */</span>    ERR_DELETE_FAILED(<span class="number">50100</span>),    <span class="comment">/**</span><span class="comment">     * 错误：修改数据错误</span><span class="comment">     */</span>    ERR_UPDATE_FAILED(<span class="number">50200</span>),    <span class="comment">/**</span><span class="comment">     * 文件上载错误</span><span class="comment">     */</span>    ERR_FILE_UPLOAD(<span class="number">50300</span>),    <span class="comment">/**</span><span class="comment">     * 错误：JWT已过期</span><span class="comment">     */</span>    ERR_JWT_EXPIRED(<span class="number">60000</span>),    <span class="comment">/**</span><span class="comment">     * 错误：验证签名失败</span><span class="comment">     */</span>    ERR_JWT_SIGNATURE(<span class="number">60100</span>),    <span class="comment">/**</span><span class="comment">     * 错误：JWT格式错误</span><span class="comment">     */</span>    ERR_JWT_MALFORMED(<span class="number">60200</span>),    <span class="comment">/**</span><span class="comment">     * 错误：JWT已经登出</span><span class="comment">     */</span>    ERR_JWT_LOGOUT(<span class="number">60300</span>),    <span class="comment">/**</span><span class="comment">     * 错误：未知错误</span><span class="comment">     */</span>    ERR_UNKNOWN(<span class="number">99999</span>);    <span class="keyword">private</span> Integer value;    ServiceCode(Integer value) &#123;        <span class="built_in">this</span>.value = value;    &#125;    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;        <span class="keyword">return</span> value;    &#125;&#125;</code></pre><h4 id="ServiceException"><a href="#ServiceException" class="headerlink" title="ServiceException"></a>ServiceException</h4><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 业务异常</span><span class="comment"> * 是异常的基础类</span><span class="comment"> * <span class="doctag">@author</span> HighEDU</span><span class="comment"> * <span class="doctag">@version</span> 0.0.1</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;    <span class="comment">/**</span><span class="comment">     * 业务状态码</span><span class="comment">     */</span>    <span class="meta">@Getter</span>    <span class="keyword">private</span> ServiceCode serviceCode;    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(ServiceCode serviceCode, String message)</span> &#123;        <span class="built_in">super</span>(message);        <span class="built_in">this</span>.serviceCode = serviceCode;    &#125;&#125;</code></pre><p>全局异常处理类</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 全局异常处理类</span><span class="comment"> */</span><span class="meta">@RestControllerAdvice</span> <span class="comment">//全局异常处理类声明</span><span class="meta">@Slf4j</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;    <span class="meta">@ExceptionHandler</span> <span class="comment">//声明处理的异常类型</span>    <span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title function_">handleServiceException</span><span class="params">(ServiceException e)</span>&#123;        log.warn(<span class="string">&quot;程序运行出现ServiceException异常,将统一处理&quot;</span>);        log.warn(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>,e.getMessage());        <span class="keyword">return</span> JsonResult.fail(e);    &#125;    <span class="comment">/**</span><span class="comment">     * 数据验证异常处理 用于处理请求参数校验失败的情况</span><span class="comment">     */</span>    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span>    <span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title function_">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span>&#123;        log.warn(<span class="string">&quot;程序运行出现MethodArgumentNotValidException异常,将统一处理&quot;</span>);        log.warn(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>,e.getMessage());        <span class="keyword">return</span> JsonResult.fail(ServiceCode.ERR_BAD_REQUEST, e.getMessage());    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker_centos</title>
      <link href="/2024/03/26/Docker-centos/"/>
      <url>/2024/03/26/Docker-centos/</url>
      
        <content type="html"><![CDATA[<h1 id="项目常用命令"><a href="#项目常用命令" class="headerlink" title="项目常用命令"></a>项目常用命令</h1><p><strong>软件信息</strong></p><table><thead><tr><th>软件名称</th><th>用户名</th><th>密码</th><th>版本号</th><th>备注</th></tr></thead><tbody><tr><td>Kylin</td><td>sir</td><td>geoDocker</td><td>v10-desktop</td><td></td></tr><tr><td>Kylin</td><td>sir</td><td>supreme</td><td>v10-server</td><td></td></tr><tr><td>Portainer</td><td>admin</td><td>geoDocker1!q</td><td>2.18.3</td><td></td></tr><tr><td>Redis</td><td></td><td>geovisRedis</td><td>7.0.11</td><td></td></tr><tr><td>Rocketmq</td><td></td><td></td><td>5.1.1</td><td></td></tr><tr><td>Postgres</td><td>postgres</td><td>geovisPostgres</td><td>15.2</td><td></td></tr><tr><td>Nginx</td><td></td><td></td><td>1.25.0</td><td></td></tr></tbody></table><p><strong>镜像信息</strong></p><table><thead><tr><th>镜像名称</th><th>拉取命令</th><th>备注</th></tr></thead><tbody><tr><td>Portainer</td><td>docker pull portainer&#x2F;portainer-ce:2.18.3-alpine</td><td></td></tr><tr><td>Rocketmq-Dashboard</td><td>docker pull apacherocketmq&#x2F;rocketmq-dashboard:latest</td><td>[地址](<a href="https://github.com/apache/rocketmq-dashboard">GitHub - apache&#x2F;rocketmq-dashboard: The state-of-the-art Dashboard of Apache RoccketMQ provides excellent monitoring capability. Various graphs and statistics of events, performance and system information of clients and application is evidently made available to the user.</a>)</td></tr><tr><td>Rocketmq</td><td>docker pull apache&#x2F;rocketmq:5.1.1</td><td>[地址](<a href="https://github.com/apache/rocketmq-docker">GitHub - apache&#x2F;rocketmq-docker: Apache RocketMQ Docker</a>)</td></tr><tr><td>Redis</td><td>docker pull redis:7.0.11-alpine</td><td></td></tr><tr><td>Postgres</td><td>docker pull postgres:15.2-alpine</td><td></td></tr><tr><td>Nginx</td><td>docker pull nginx:1.25.0-alpine</td><td></td></tr></tbody></table><h2 id="Nginx-启动命令"><a href="#Nginx-启动命令" class="headerlink" title="Nginx 启动命令"></a>Nginx 启动命令</h2><pre><code class="highlight bash">docker run -d --name nginx -p 80:80 -v /ss-data/nginx/nginx.conf:/etc/nginx/nginx.conf -v /ss-data/nginx/logs:/var/log/nginx -v /ss-data/nginx/html:/usr/share/nginx/html -v /ss-data/nginx/conf:/etc/nginx/conf.d --privileged=<span class="literal">true</span> nginx</code></pre><h2 id="1-开启ssh服务"><a href="#1-开启ssh服务" class="headerlink" title="1. 开启ssh服务"></a>1. 开启ssh服务</h2><pre><code class="highlight plaintext">systemctl enable ssh.service</code></pre><h2 id="2-离线安装"><a href="#2-离线安装" class="headerlink" title="2. 离线安装"></a>2. 离线安装</h2><pre><code class="highlight sh">tar -zxvf docker-24.0.2.tgzsudo <span class="built_in">mv</span> docker/* /usr/bin/</code></pre><h2 id="3-添加开机启动"><a href="#3-添加开机启动" class="headerlink" title="3. 添加开机启动"></a>3. 添加开机启动</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">添加开机启动配置</span>sudo vim /usr/lib/systemd/system/docker.service</code></pre><p><strong>文件内容</strong></p><pre><code class="highlight plaintext">[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notifyExecStart=/usr/bin/dockerdExecReload=/bin/kill -s HUP $MAINPIDLimitNOFILE=infinityLimitNPROC=infinityTimeoutStartSec=0Delegate=yesKillMode=processRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.target</code></pre><p><strong>添加执行权限</strong></p><pre><code class="highlight sh"><span class="built_in">chmod</span> +x /usr/lib/systemd/system/docker.servicesudo systemctl daemon-reload</code></pre><p><strong>启动Docker</strong></p><pre><code class="highlight sh">sudo systemctl start docker</code></pre><p><strong>配置开机启动</strong></p><pre><code class="highlight sh">sudo systemctl <span class="built_in">enable</span> docker</code></pre><p>如果上面的命令执行不成功，可通过以下方式实现</p><pre><code class="highlight sh"><span class="built_in">echo</span> <span class="string">&quot;systemctl start docker&quot;</span> &gt; /etc/rc.local<span class="built_in">chmod</span> +x /etc/rc.local</code></pre><h2 id="4-Portainer启动命令"><a href="#4-Portainer启动命令" class="headerlink" title="4. Portainer启动命令"></a>4. Portainer启动命令</h2><pre><code class="highlight sh"><span class="comment"># 启动 docker 镜像</span>docker run -p 9000:9000 -p 8000:8000 --name portainer \--restart=always \-v /var/run/docker.sock:/var/run/docker.sock \-v /mnt/docker_data/portainer/data:/data \-d portainer/portainer-ce:2.18.3-alpine</code></pre><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><pre><code class="highlight plaintext"># 将容器nginx.conf文件复制到宿主机docker cp d576bf1439d8:/etc/nginx/nginx.conf   /mnt/docker_data/nginx/conf/nginx.conf# 将容器conf.d文件夹下内容复制到宿主机docker cp d576bf1439d8:/etc/nginx/conf.d   /mnt/docker_data/nginx/conf/conf.d# 将容器中的html文件夹复制到宿主机docker cp d576bf1439d8:/usr/share/nginx/html  /mnt/docker_data/nginx/static</code></pre><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Portainer-Stacks"><a href="#Portainer-Stacks" class="headerlink" title="Portainer Stacks"></a>Portainer Stacks</h3><p><strong>basic</strong></p><pre><code class="highlight yaml"><span class="attr">version:</span> <span class="string">&quot;3.5&quot;</span><span class="attr">networks:</span>  <span class="attr">default:</span>    <span class="attr">external:</span> <span class="literal">true</span>    <span class="attr">name:</span> <span class="string">data</span>    <span class="attr">services:</span>   <span class="comment"># Redis 服务</span>  <span class="attr">redis:</span>    <span class="attr">image:</span> <span class="string">redis:7.0.11-alpine</span>    <span class="attr">container_name:</span> <span class="string">redis</span>    <span class="attr">restart:</span> <span class="string">always</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="string">&#x27;6379:6379&#x27;</span>    <span class="attr">volumes:</span>        <span class="bullet">-</span> <span class="string">/mnt/docker_data/redis/data:/data</span>        <span class="bullet">-</span> <span class="string">/mnt/docker_data/redis/config/redis.conf:/usr/local/etc/redis/redis.conf</span>        <span class="bullet">-</span> <span class="string">/mnt/docker_data/redis/log:/logs</span>    <span class="attr">command:</span>      <span class="string">redis-server</span> <span class="string">/usr/local/etc/redis/redis.conf</span>    <span class="comment">#Nginx 服务</span>  <span class="attr">nginx:</span>    <span class="attr">image:</span> <span class="string">nginx:1.25.0-alpine</span>    <span class="attr">container_name:</span> <span class="string">nginx</span>    <span class="attr">restart:</span> <span class="string">always</span>    <span class="attr">ports:</span>       <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span>    <span class="attr">volumes:</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/nginx/conf/conf.d:/etc/nginx/conf.d</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/nginx/static:/usr/share/nginx/html</span>  <span class="comment"># RocketMQ NameServer 服务</span>  <span class="attr">namesrv:</span>    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.1.1</span>    <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span>    <span class="attr">restart:</span> <span class="string">always</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span>    <span class="attr">volumes:</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/rocketmq/namesrv/logs:/home/rocketmq/logs</span>    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span>      <span class="comment"># RocketMQ Broker 服务</span>  <span class="attr">broker:</span>    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.1.1</span>    <span class="attr">container_name:</span> <span class="string">rmqbroker</span>    <span class="attr">restart:</span> <span class="string">always</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span>      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span>      <span class="bullet">-</span> <span class="number">10912</span><span class="string">:10912</span>    <span class="attr">volumes:</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/rocketmq/broker/logs:/home/rocketmq/logs</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/rocketmq/broker/store:/home/rocketmq/store</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/rocketmq/broker/conf/broker.conf:/home/rocketmq/rocketmq-5.1.1/conf/broker.conf</span>    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span> <span class="string">-n</span> <span class="string">namesrv:9876</span> <span class="string">-c</span> <span class="string">../conf/broker.conf</span>    <span class="attr">depends_on:</span>      <span class="bullet">-</span> <span class="string">namesrv</span>  <span class="comment"># RocketMQ 仪表盘</span>  <span class="attr">rocketmq-dashboard:</span>    <span class="attr">image:</span> <span class="string">apacherocketmq/rocketmq-dashboard:latest</span>    <span class="attr">container_name:</span> <span class="string">rocketmq-dashboard</span>    <span class="attr">restart:</span> <span class="string">always</span>    <span class="attr">depends_on:</span>      <span class="bullet">-</span> <span class="string">namesrv</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="string">&#x27;28080:8080&#x27;</span>    <span class="attr">environment:</span>      <span class="bullet">-</span> <span class="string">JAVA_OPTS=-Drocketmq.namesrv.addr=192.168.32.200:9876</span>  <span class="comment"># Postgresql 服务</span>  <span class="attr">postgres:</span>    <span class="attr">image:</span> <span class="string">postgres:15.2-alpine</span>    <span class="attr">container_name:</span> <span class="string">postgres</span>    <span class="attr">restart:</span> <span class="string">always</span>    <span class="attr">ports:</span>      <span class="bullet">-</span> <span class="number">5432</span><span class="string">:5432</span>    <span class="attr">environment:</span>      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=geovisPostgres</span>      <span class="bullet">-</span> <span class="string">ALLOW_IP_RANGE=0.0.0.0/0</span>      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span>      <span class="bullet">-</span> <span class="string">PGTZ=Asia/Shanghai</span>    <span class="attr">volumes:</span>      <span class="bullet">-</span> <span class="string">/mnt/docker_data/postgres/data:/var/lib/postgresql/data</span>    <span class="attr">logging:</span>       <span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span>      <span class="attr">options:</span>         <span class="attr">max-size:</span> <span class="string">&quot;10m&quot;</span>           <span class="comment"># MySQL 服务  </span>  <span class="attr">mysql:</span>      <span class="attr">image:</span> <span class="string">mysql:5.7</span>     <span class="attr">container_name:</span> <span class="string">mysql</span>       <span class="attr">restart:</span> <span class="string">always</span>      <span class="attr">ports:</span>        <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span>      <span class="attr">environment:</span>        <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span>        <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=root</span>       <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span>      <span class="attr">volumes:</span>        <span class="bullet">-</span> <span class="string">/mnt/docker_data/mysql/data:/var/lib/mysql</span>      <span class="attr">logging:</span>         <span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span>        <span class="attr">options:</span>           <span class="attr">max-size:</span> <span class="string">&quot;10m&quot;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
